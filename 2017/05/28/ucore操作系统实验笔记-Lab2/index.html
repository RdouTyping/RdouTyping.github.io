<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="ucore,OS," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="这是ucore Lab2的实验笔记，这个实验要我们填写的内容不算很难，但实验外的东西却很值得研究。Lab1和Lab2是这门课实验的一道坎，要想完成接下来的实验，这两个实验一定要搞懂。通过这个实验，我们可以了解系统内存的探测，内存物理页的管理，ucore不同阶段的地址映射等。">
<meta name="keywords" content="ucore,OS">
<meta property="og:type" content="article">
<meta property="og:title" content="ucore操作系统实验笔记-Lab2">
<meta property="og:url" content="http://yoursite.com/2017/05/28/ucore操作系统实验笔记-Lab2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="这是ucore Lab2的实验笔记，这个实验要我们填写的内容不算很难，但实验外的东西却很值得研究。Lab1和Lab2是这门课实验的一道坎，要想完成接下来的实验，这两个实验一定要搞懂。通过这个实验，我们可以了解系统内存的探测，内存物理页的管理，ucore不同阶段的地址映射等。">
<meta property="og:image" content="https://objectkuan.gitbooks.io/ucore-docs/lab2_figs/image003.png">
<meta property="og:image" content="https://www.cs.rutgers.edu/~pxk/416/notes/images/09a-ia32-seg_paging.png">
<meta property="og:image" content="http://wiki.osdev.org/images/9/94/Page_dir.png">
<meta property="og:image" content="http://wiki.osdev.org/images/9/9b/Page_table.png">
<meta property="og:updated_time" content="2017-05-31T07:16:18.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ucore操作系统实验笔记-Lab2">
<meta name="twitter:description" content="这是ucore Lab2的实验笔记，这个实验要我们填写的内容不算很难，但实验外的东西却很值得研究。Lab1和Lab2是这门课实验的一道坎，要想完成接下来的实验，这两个实验一定要搞懂。通过这个实验，我们可以了解系统内存的探测，内存物理页的管理，ucore不同阶段的地址映射等。">
<meta name="twitter:image" content="https://objectkuan.gitbooks.io/ucore-docs/lab2_figs/image003.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/05/28/ucore操作系统实验笔记-Lab2/"/>





  <title>ucore操作系统实验笔记-Lab2 | Hexo</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/28/ucore操作系统实验笔记-Lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ruitao Dou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/Me and My Wife.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ucore操作系统实验笔记-Lab2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-28T22:24:41-07:00">
                2017-05-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">本文总阅读量
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>这是ucore Lab2的实验笔记，这个实验要我们填写的内容不算很难，但实验外的东西却很值得研究。Lab1和Lab2是这门课实验的一道坎，要想完成接下来的实验，这两个实验一定要搞懂。通过这个实验，我们可以了解系统内存的探测，内存物理页的管理，ucore不同阶段的地址映射等。</p>
</blockquote>
<a id="more"></a>
<h2 id="系统内存的探测"><a href="#系统内存的探测" class="headerlink" title="系统内存的探测"></a>系统内存的探测</h2><h3 id="INT-15h中断与E820参数"><a href="#INT-15h中断与E820参数" class="headerlink" title="INT 15h中断与E820参数"></a>INT 15h中断与E820参数</h3><p>在我们分配物理内存空间前，我们必须要获取物理内存空间的信息 - 比如哪些地址空间可以使用，哪些地址空间不能使用等。在本实验中， 我们通过向INT 15h中断传入e820h参数来探测物理内存空间的信息(除了这种方法外，我们还可以使用其他的方法，具体如何使用这些方法请自行网上搜索)。<br>下面我们来看一下ucore中物理内存空间的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">e820map:</div><div class="line">  memory: 0009fc00, [00000000, 0009fbff], type = 1.</div><div class="line">  memory: 00000400, [0009fc00, 0009ffff], type = 2.</div><div class="line">  memory: 00010000, [000f0000, 000fffff], type = 2.</div><div class="line">  memory: 07ee0000, [00100000, 07fdffff], type = 1.</div><div class="line">  memory: 00020000, [07fe0000, 07ffffff], type = 2.</div><div class="line">  memory: 00040000, [fffc0000, ffffffff], type = 2.</div></pre></td></tr></table></figure>
<p>这里的type是物理内存空间的类型，1是可以使用的物理内存空间， 2是不能使用的物理内存空间。注意， 2中的”不能使用”指的是这些地址不能映射到物理内存上， 但它们可以映射到ROM或者映射到其他设备，比如各种外设等。</p>
<p>除了这两种类型，还有几种其他类型，只是在这个实验中我们并没有使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">type = 3: ACPI Reclaim Memory (usable by OS after reading ACPI tables)</div><div class="line">type = 4: ACPI NVS Memory (OS is required to save this memory between NVS sessions)</div><div class="line">type = other: not defined yet -- treat as Reserved</div></pre></td></tr></table></figure>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>要使用这种方法来探测物理内存空间，我们必须将系统置于实模式下。因此， 我们在bootloader中添加了物理内存空间探测的功能。 这种方法获取的物理内存空间的信息是用内存映射地址描述符(Address Range Descriptor)来表示的，一个内存映射地址描述符占20B，其具体描述如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">00h    8字节   base address            #系统内存块基地址</div><div class="line">08h    8字节   length in bytes         #系统内存大小</div><div class="line">10h    4字节   type of address range   #内存类型</div></pre></td></tr></table></figure>
<p>每探测到一块物理内存空间， 其对应的内存映射地址描述符就会被写入我们指定的内存空间(可以理解为是内存映射地址描述符表)。 当完成物理内存空间的探测后， 我们就可以通过这个表来了解物理内存空间的分布情况了。</p>
<p>下面我们来看看INT 15h中断是如何进行物理内存空间的探测：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* memlayout.h */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> nr_map;</div><div class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> addr;</div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> size;</div><div class="line">        <span class="keyword">long</span> type;</div><div class="line">   &#125; <span class="built_in">map</span>[E820MAX];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/* bootasm.S */</span></div><div class="line">probe_memory:</div><div class="line">    <span class="comment">/* 在0x8000处存放struct e820map, 并清除e820map中的nr_map */</span></div><div class="line">    movl $<span class="number">0</span>, <span class="number">0x8000</span></div><div class="line">    xorl %ebx, %ebx</div><div class="line">    <span class="comment">/* 0x8004处将用于存放第一个内存映射地址描述符 */</span></div><div class="line">    movw $<span class="number">0x8004</span>, %di</div><div class="line">start_probe:</div><div class="line">    <span class="comment">/* 传入0xe820作为INT 15h中断的参数 */</span></div><div class="line">    movl $<span class="number">0xE820</span>, %eax</div><div class="line">    <span class="comment">/* 内存映射地址描述符的大小 */</span></div><div class="line">    movl $<span class="number">20</span>, %ecx</div><div class="line">    movl $SMAP, %edx</div><div class="line">    <span class="comment">/* 调用INT 15h中断 */</span></div><div class="line">    <span class="keyword">int</span> $<span class="number">0x15</span></div><div class="line">    <span class="comment">/* 如果eflags的CF位为0，则表示还有内存段需要探测 */</span></div><div class="line">    jnc cont</div><div class="line">    movw $<span class="number">12345</span>, <span class="number">0x8000</span></div><div class="line">    jmp finish_probe</div><div class="line">cont:</div><div class="line">    <span class="comment">/* 设置下一个内存映射地址描述符的起始地址 */</span></div><div class="line">    addw $<span class="number">20</span>, %di</div><div class="line">    <span class="comment">/* e820map中的nr_map加1 */</span></div><div class="line">    incl <span class="number">0x8000</span></div><div class="line">    <span class="comment">/* 如果还有内存段需要探测则继续探测, 否则结束探测 */</span></div><div class="line">    cmpl $<span class="number">0</span>, %ebx</div><div class="line">    jnz start_probe</div><div class="line">finish_probe:</div></pre></td></tr></table></figure></p>
<p>从上面代码可以看出，要实现物理内存空间的探测，大体上只需要3步：</p>
<ol>
<li>设置一个存放内存映射地址描述符的物理地址(这里是0x8000)</li>
<li>将e820作为参数传递给INT 15h中断</li>
<li>通过检测eflags的CF位来判断探测是否结束。如果没有结束， 设置存放下一个内存映射地址描述符的物理地址，然后跳到步骤2；如果结束，则程序结束</li>
</ol>
<h2 id="物理内存空间管理的初始化"><a href="#物理内存空间管理的初始化" class="headerlink" title="物理内存空间管理的初始化"></a>物理内存空间管理的初始化</h2><p>当我们在bootloader中完成对物理内存空间的探测后， 我们就可以根据得到的信息来对可用的内存空间进行管理。在ucore中， 我们将物理内存空间按照页的大小(4KB)进行管理， 页的信息用Page这个结构体来保存。下面是Page在Lab2中的具体描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> ref;                        <span class="comment">// page frame's reference counter</span></div><div class="line">    <span class="keyword">uint32_t</span> flags;                 <span class="comment">// array of flags that describe the status of the page frame</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> property;          <span class="comment">// the num of free block, used in first fit pm manager</span></div><div class="line">    <span class="keyword">list_entry_t</span> page_link;         <span class="comment">// free list link</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们下面来看看程序是如何初始化物理内存空间的页信息的。</p>
<h3 id="物理内存空间管理的初始化的过程"><a href="#物理内存空间管理的初始化的过程" class="headerlink" title="物理内存空间管理的初始化的过程"></a>物理内存空间管理的初始化的过程</h3><p>物理内存空间的初始化可以分为以下4步：</p>
<ol>
<li>根据物理内存空间探测的结果， 找到最后一个可用空间的结束地址(ucore中就是0x07FDFFFF)或者KMEMSIZE(0x38000000)，选一个小的。根据这个结束地址计算出整个可用的物理内存空间一共有多少个页。</li>
<li>找到Kernel的结束地址(end)，这个地址是在kernel.ld中定义的， 我们从这个地址所在的下一个页开始(pages)写入系统页的信息(将所有的Page写入这个地址)</li>
<li>从pages开始，将所有页的信息的flag都设置为reserved(不可用)</li>
<li>找到free页的开始地址， 并初始化所有free页的信息(free页就是除了kernel和页信息外的可用空间，初始化的过程会reset flag中的reserved位)</li>
</ol>
<p>上面这几部中提到了很多地址空间， 下面我用一幅图来说明：<br><img src="https://objectkuan.gitbooks.io/ucore-docs/lab2_figs/image003.png" alt="物理内存空间的分布图"></p>
<p>end指的就是BSS的结束处；pages指的是BSS结束处 - 空闲内存空间的起始地址；free页是从空闲内存空间的起始地址 -  实际物理内存空间结束地址。</p>
<p>有了这幅图，这些地址就很容易理解了。 </p>
<h3 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h3><h4 id="pages的地址"><a href="#pages的地址" class="headerlink" title="pages的地址"></a>pages的地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);</div></pre></td></tr></table></figure>
<h4 id="free页的起始地址"><a href="#free页的起始地址" class="headerlink" title="free页的起始地址"></a>free页的起始地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);</div></pre></td></tr></table></figure>
<h4 id="初始化free页的信息"><a href="#初始化free页的信息" class="headerlink" title="初始化free页的信息"></a>初始化free页的信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">init_memmap(pa2page(begin), (end - begin) / PGSIZE);</div></pre></td></tr></table></figure>
<p>从pages开始保存了所有物理页的信息(严格来讲， 在pages处保存的npage个页的信息并不一定是所有的物理页信息，它还包括各种外设地址，ROM地址等。不过因为它包含了所有可用free页的信息，我们就可以使用pages来找到任何free页的信息)。 那如何将free页的信息和free页联系起来呢？很简单， 我们用地址的物理页号(pa的高20bit)作为index来定位free页的信息。 因为pages处保存了系统中的第一个物理页的页信息，只要我们知道某个页的物理地址， 我们就可以很容易的找到它的页号(pa &gt;&gt; 12)。 有了页号，我们就可以通过pages[页号]来定位其页的信息了。在本lab中， 获取页的信息是由 <code>pa2page()</code> 来完成的。</p>
<p>在初始化free页的信息时， 我们只将连续多个free页中第一个页的信息连入free_list中， 并且只将这个页的property设置为连续多个free页的个数。 其他所有页的信息我们只是简单的设置为0。</p>
<h2 id="内存段页式管理"><a href="#内存段页式管理" class="headerlink" title="内存段页式管理"></a>内存段页式管理</h2><p>这个lab中最重要的一个知识点就是内存的段页式管理。 下图是段页式内存管理的示意图：</p>
<p><img src="https://www.cs.rutgers.edu/~pxk/416/notes/images/09a-ia32-seg_paging.png" alt="段页式内存管理"></p>
<p>我们可以看到，在这种模式下，逻辑地址先通过段机制转化成线性地址， 然后通过两种页表(页目录和页表)来实现线性地址到物理地址的转换。 有一点需要注意，在页目录和页表中存放的地址都是物理地址。</p>
<p>下面是页目录表表项：</p>
<p><img src="http://wiki.osdev.org/images/9/94/Page_dir.png" alt="页目录表表项"></p>
<p>下面是页表表项:</p>
<p><img src="http://wiki.osdev.org/images/9/9b/Page_table.png" alt="页表表项"></p>
<p>在X86系统中，页目录表的起始物理地址存放在cr3 寄存器中， 这个地址必须是一个页对齐的地址，也就是低 12 位必须为0。在ucore 用boot_cr3（mm/pmm.c）记录这个值。</p>
<p>在ucore中，线性地址的的高10位作为页目录表的索引，之后的10位作为页表的的索引，所以页目录表和页表中各有1024个项，每个项占4B，所以页目录表和页表刚好可以用一个物理的页来存放。</p>
<h2 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h2><p>在这个实验中，我们在4个不同的阶段使用了四种不同的地址映射， 下面我就分别介绍这4种地址映射。</p>
<h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p>这一阶段是从bootasm.S的start到entry.S的kern_entry前，这个阶段很简单， 和lab1一样(这时的GDT中每个段的起始地址都是0x00000000并且此时kernel还没有载入)。</p>
<blockquote>
<p>virt addr = linear addr = phy addr</p>
</blockquote>
<h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p>这个阶段就是从entry.S的kern_entry到pmm.c的enable_paging()。 这个阶段就比较复杂了，我们先来看bootmain.c这个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define ELFHDR          ((struct elfhdr *)0x10000)      // scratch space</div></pre></td></tr></table></figure>
<p>bootmain.c中的函数被调用时候还处于第一阶段， <del>所以从上面这个宏定义我们可以知道kernel是被放在物理地址为0x10000的内存空间。</del> 通过上面的宏我们可以知道ELFHDR从硬盘的第一个扇区读出后放在了内存中的0x10000这个位置。 这个地址和kernel载入的地址没有任何关系。kernel的载入地址在链接文件kernel.ld中定义，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/* Load the kernel at this address: &quot;.&quot; means the current address */</div><div class="line">    . = 0xC0100000;</div></pre></td></tr></table></figure>
<p>链接文件将kernel链接到了0xC0100000(这是Higher Half Kernel， 具体参考<a href="http://wiki.osdev.org/Higher_Half_Kernel" target="_blank" rel="external">Higher Half Kernel</a>)，这个地址是kernel的虚拟地址。 链接文件kernel.ld定义了ucore的链接地址，bootmain.c这个文件定义了ucore的加载地址，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* p_va是段的第一个字节将被放到内存中的虚拟地址 */</span></div><div class="line"><span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</div><div class="line">    readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这个地方我们可以看出，ucore实际加载的物理地址应该是0x00FFFFFF &amp; ucore虚拟地址，所以结合链接地址，我们可以知道ucore加载的物理地址是0x00100000。由于此时系统还只是采用段式映射，如果我们还是使用</p>
<blockquote>
<p>virt addr = linear addr = phy addr</p>
</blockquote>
<p>的话，我们根本不能访问到正确的内存空间，比如要访问虚拟地址0xC0100000， 其物理地址应该在0x00100000，而在这种映射下， 我们却访问了0xC0100000的物理地址。因此， 为了让虚拟地址和物理地址能匹配，我们必须要重新设计GDT。</p>
<p>在entry.S中，我们重新设计了GDT，其形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#define REALLOC(x) (x - KERNBASE)</div><div class="line"></div><div class="line">lgdt REALLOC(__gdtdesc)</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">__gdt:</div><div class="line">    SEG_NULL</div><div class="line">    SEG_ASM(STA_X | STA_R, - KERNBASE, 0xFFFFFFFF)      # code segment</div><div class="line">    SEG_ASM(STA_W, - KERNBASE, 0xFFFFFFFF)              # data segment</div><div class="line">__gdtdesc:</div><div class="line">    .word 0x17                                          # sizeof(__gdt) - 1</div><div class="line">    .long REALLOC(__gdt)</div></pre></td></tr></table></figure>
<p>可以看到，此时段的起始地址由0变成了-KERNBASE。因此，在这个阶段， 地址映射关系为：</p>
<blockquote>
<p>virt addr - 0xC0000000 = linear addr = phy addr</p>
</blockquote>
<p>这里需要注意两个个地方，第一，lgdt载入的是线性地址，所以用.long REALLOC(__gdt)将GDT的虚拟地址转换成了线性地址；第二，因为在载入GDT前，映射关系还是</p>
<blockquote>
<p>virt addr = linear addr = phy addr</p>
</blockquote>
<p>所以通过REALLOC(__gdtdesc)来将__gdtdesc的虚拟地址转换为物理地址，这样，lgdt才能真正的找到GDT存储的地方。第三，bootmain.c中，我们使用物理地址来定位到了entry.S的kern_entry，所以我们可以在载入新的GDT前正确的运行lgdt REALLOC(__gdtdesc)这条语句。</p>
<h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p>这个阶段是从kmm.c的enable_paging()到kmm.c的gdt_init()。 这个阶段是最复杂的阶段，我们开启了页机制， 并且在boot_map_segment()中将线性地址按照如下规则进行映射：</p>
<blockquote>
<p>linear addr - 0xC0000000 = phy addr</p>
</blockquote>
<p>这就导致此时虚拟地址，线性地址和物理地址之间的关系如下：</p>
<blockquote>
<p>virt addr = linear addr + 0xC0000000 = phy addr + 2 * 0xC0000000</p>
</blockquote>
<p>这肯定是错误的，因为我们根本不能通过虚拟地址获取正确的物理地址， 我们可以继续用之前例子。我们还是要访问虚拟地址0xC0100000， 则其线性地址就是0x00100000，然后通过页映射后的物理地址是0x80100000。 我们本来是要访问0x00100000，却访问了0x80100000， 因此我们需要想办法来解决这个问题，即要让映射还是：</p>
<blockquote>
<p>virt addr - 0xC0000000 = linear addr = phy addr</p>
</blockquote>
<p>这个和第一阶段到第二阶段的转变类似，都是需要调整映射关系。为了解决这个问题, ucore使用了一个小技巧：<br>在boot_map_segment()中， 线性地址0xC0000000-0xC0400000(4MB)对应的物理地址是0x00000000-0x00400000(4MB)。如果我们还想使用虚拟地址0xC0000000来映射物理地址0x00000000， 也就是线性地址0x00000000来映射物理地址0x00000000，我们可以这么做：</p>
<blockquote>
<p>在开启页映射机制前， 将页目录表中的第0项和第0b1100_0000_00设置为相同的映射(boot_pgdir[0] = boot_pgdir[PDX(KERNBASE)])，这样，当虚拟地址是0xC0000000时， 其对应的线性地址就是0x00000000， 然后通过页表可以知道其物理地址也是0x00000000。</p>
<p>举个例子，比如enable_paging()后应该运行gdt_init()，gdt_init()的虚拟地址是0xC01033CF，那么其对应的线性地址就是0x001033CF，它将映射到页目录表的第一项。并且这个线性地址和0xC01033CF最终是指向同一个物理页，它们对应的物理地址是0x001033CF。而根据gdt_init()的虚拟地址和链接地址可知，gdt_init()的物理地址就是0x001033CF，因此通过这种地址变换后，我们可以正确的取到之后的指令。</p>
</blockquote>
<p>因为ucore在当前lab下的大小是小于4MB的，因此这么做之后， 我们依然可以按照阶段二的映射方式运行ucore。如果ucore的大小大于了4MB， 我们只需按同样的方法设置页目录表的第1,2,3…项。</p>
<h3 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h3><p>这一阶段开始于kmm.c的gdt_init()。gdt_init()重新设置GDT, 新的GDT又将段的起始地址变为了0. 调整后, 地址的映射关系终于由</p>
<blockquote>
<p>virt addr = linear addr + 0xC0000000 = phy addr + 2 * 0xC0000000</p>
</blockquote>
<p>变回了</p>
<blockquote>
<p>virt addr = linear addr = phy addr + 0xC0000000</p>
</blockquote>
<p>同时，我们把目录表中的第0项设置为0，这样就把之前的这种映射关系解除了。通过这几个步骤的转换， 我们终于在开启页映射机制后将映射关系设置正确了。</p>
<h2 id="自映射"><a href="#自映射" class="headerlink" title="自映射"></a>自映射</h2><p>在这个实验中，为了方便快速地访问页目录项和页表项，用了一个小技巧 - 也就是自映射。如果用常规方法的话，要访问一个页表项，必须先使用虚拟地址访问到对应的页目录项，然后通过其中的页表地址找到页表，最后再通过虚拟地址的页表项部分找到我们需要的页表项。这个过程是比较繁琐的，为了方便的访问这些表项，我们使用了自映射。我们下面通过代码来看看什么是自映射以及如何使用自映射来快速查找表项的内容。</p>
<h3 id="自映射的实现"><a href="#自映射的实现" class="headerlink" title="自映射的实现"></a>自映射的实现</h3><p>首先，我们将页一个目录项的值设置为页目录表的物理地址，这么做的作用就是当我们使用的虚拟地址，高10位为1111 1010 11b时，它对应的页表就是页目录表，这也就实现了自映射：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* VPT = 0xFAC00000 = 1111 1010 11 | 00 0000 0000 | 0000 0000 0000b </span></div><div class="line">注意，这个地址是在ucore有效地址之外的地址(有效地址从0xC0000000到0xF8000000) */</div><div class="line">boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;</div></pre></td></tr></table></figure>
<p>这样之后，我们来看看如何使用这种自映射。我们还定义了一个地址VPD：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VPD = 0xFAFEB000 = 1111 1010 11 | 11 1110 1011 | 0000 0000 0000b</div></pre></td></tr></table></figure>
<p>通过VPD和VPT，我们就能方便的访问页目录项和页表项了。下面给一个例子说明如何获取0xF8000000所在的页目录项和页表项：<br>首先，我们思考下直接通过VPD = 1111 1010 11 | 11 1110 1011 | 0000 0000 0000b这个地址我们能访问到什么？在页目录表中通过1111 1010 11可以找到boot_pgdir[PDX(VPT)]这项，这项又直接指回了boot_pgdir，此时我们将页目录表当成了页表。我们此时再用第二个11 1110 1011，还是找到boot_pgdir[PDX(VPT)]这项，它还是指回boot_pgdir。也就是说，VPD这个地址最终就是指回了页目录表，并且我们可以通过它的最后12bit来访问页目录表。0xF8000000地址对应的页目录项是1111 1000 00b，我们只要将这个值放在VPD的后12bit就行了(因为12bit是大于10bit的，因此我们一定能找到需要访问的页目录项)，也就是说我们通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VPD + 0xF8000000 &gt;&gt; 22</div></pre></td></tr></table></figure>
<p>就可以获得0xF8000000对应的页目录项。如果懂了如何获取页目录项，再来看如何获取页表项就很简单了。首先，我们根据VPT可以访问到页目录表，这个页目录表同样也是VPT对应的页表，通过VPT的低22位我们就可以像访问页表一样的访问页目录表。0xF8000000的高20位是1111 1000 0000 0000  0000b，用这个地址我们就可以通过页目录表找到它对应的页表项了。这里我觉得指导书上说的不对，如果要能访问一个非4MB对齐的地址，不能直接使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VPT + addr &gt;&gt; 12</div></pre></td></tr></table></figure>
<p>而要用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VPT + [addr_31_22 : 00 : addr_21_12]</div></pre></td></tr></table></figure>
<p>比如一个高20位地址是1111 1000 11|00 0000 0011b，那么要用在VPT中，1111 1000 11要放在VPT的21_12位，用于找到页目录表项，从而找到页表，剩下的00 0000 0003就要用来在页表中找页表项。因为VPT中的低22位为0，如果直接使用addr &gt;&gt; 22的话，那么1111 1000 11|00 0000 0011b就变成了0011 1110 00| 1100 0000 0011b，这样的话，用于查找页目录项和页表项的索引就不对了，所以我觉得应该是我说的那种转换方法。也即是1111 1000 11|00 0000 0011b变成了1111 1000 11|0000 0000 0011b，这样才和之前的是对应的。如果要访问的地址是4MB对齐的，那么就可以直接用VPT + addr &gt;&gt; 12了。</p>
<h2 id="Task1"><a href="#Task1" class="headerlink" title="Task1"></a>Task1</h2><p>这个练习是实现first-fit连续物理内存分配算法。难度不大，主要通过实现两个函数 <code>default_alloc_pages(size_t n)</code> 和 <code>default_free_pages(struct Page *base, size_t n)</code>。 下面是这两个函数的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* default_pmm.c */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> struct Page *</span></div><div class="line"><span class="title">default_alloc_pages</span><span class="params">(<span class="keyword">size_t</span> n)</span> &#123;</div><div class="line">    assert(n &gt; <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (n &gt; nr_free) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> = <span class="title">NULL</span>;</span></div><div class="line">    <span class="keyword">list_entry_t</span> *le = &amp;free_list;</div><div class="line">    <span class="comment">/* find the fist memory block that is larger or equal to n pages */</span>  </div><div class="line">    <span class="keyword">while</span> ((le = list_next(le)) != &amp;free_list) &#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">le2page</span>(<span class="title">le</span>, <span class="title">page_link</span>);</span></div><div class="line">        <span class="keyword">if</span> (p-&gt;property &gt;= n) &#123;</div><div class="line">            page = p;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="comment">/* if the memory block is larger than n pages, we need to divide this </span></div><div class="line">         * memory block to two pieces and add the second piece to the free_list.</div><div class="line">         * Item in free list should be sorted by address */ </div><div class="line">        <span class="keyword">if</span> (page-&gt;property &gt; n) &#123;</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">page</span> + <span class="title">n</span>;</span></div><div class="line">            p-&gt;property = page-&gt;property - n;</div><div class="line">            list_add_after(&amp;(page-&gt;page_link), &amp;(p-&gt;page_link));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/* cleanup Page information and remove it from free_list */</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">            ClearPageProperty(page + i);</div><div class="line">        page-&gt;property = <span class="number">0</span>;</div><div class="line">        list_del(&amp;(page-&gt;page_link));</div><div class="line">        nr_free -= n;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> page;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>default_alloc_pages(size_t n)</code> 会返回分配的物理页对应的页信息，根据页信息，我们可以通过计算它的index(page - pages)来获取物理页的物理页号。之后根据各种转换，我们就能知道物理页的物理地址和虚拟地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* default_pmm.c */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">default_free_pages</span><span class="params">(struct Page *base, <span class="keyword">size_t</span> n)</span> &#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></div><div class="line">    assert(n &gt; <span class="number">0</span>);</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">base</span>;</span></div><div class="line">    <span class="keyword">for</span> (; p != base + n; p ++) &#123;</div><div class="line">        <span class="comment">/* !PageProperty(p) checks two things: </span></div><div class="line">         * 1. whether base belongs to free or allocated pages. If page is allocated, Property flag </div><div class="line">         * is set to 0; If page is free, Property flag is set to 1. </div><div class="line">         * 2. whether base + n across the boundary of base memory block. </div><div class="line">         * The Property flag of allocated page is set to 0, is one page's Property flag is set to 1, </div><div class="line">         * base + n must across the boundary. */ </div><div class="line">        assert(!PageReserved(p) &amp;&amp; !PageProperty(p));</div><div class="line">        p-&gt;flags = <span class="number">0</span>;</div><div class="line">        set_page_ref(p, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    base-&gt;property = n;</div><div class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;free_list);</div><div class="line">    <span class="comment">/* find the first Page in free_list that address is larger than base */</span> </div><div class="line">    <span class="keyword">while</span> (le != &amp;free_list) &#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">le2page</span>(<span class="title">le</span>, <span class="title">page_link</span>);</span> </div><div class="line">        <span class="keyword">if</span> (p &gt; base)</div><div class="line">           <span class="keyword">break</span>; </div><div class="line">        le = list_next(le);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* there are two cases here: </span></div><div class="line">     * 1. free_list is not empty </div><div class="line">     * 2. we can find a Page in free_list that address is larger than base */</div><div class="line">    <span class="keyword">if</span> (le != &amp;free_list) &#123;</div><div class="line">        next = le2page(le, page_link);</div><div class="line">        <span class="comment">/* if we can combine base and next memory spaces, just do it. But we should not insert base to free_list here. </span></div><div class="line">         * We will deal with this later */</div><div class="line">        <span class="keyword">if</span> (base + n == next) &#123;</div><div class="line">            base-&gt;property += next-&gt;property;</div><div class="line">            next-&gt;property = <span class="number">0</span>; </div><div class="line">            list_del(&amp;(next-&gt;page_link));</div><div class="line">        &#125; </div><div class="line">        <span class="comment">/* if base's address is smaller than the first Page's address, we just insert base to free_list */</span></div><div class="line">        <span class="keyword">if</span> (le-&gt;prev == &amp;free_list) &#123;</div><div class="line">            list_add_after(&amp;(free_list), &amp;(base-&gt;page_link));</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            prev = le2page(le-&gt;prev, page_link);</div><div class="line">            <span class="comment">/* if we can combine base and previous memory spaces, just do it. In this case, we do not need </span></div><div class="line">             * to insert base to free_list */</div><div class="line">            <span class="keyword">if</span> (prev + prev-&gt;property == base) &#123;</div><div class="line">                prev-&gt;property += base-&gt;property;</div><div class="line">                base-&gt;property = <span class="number">0</span>;</div><div class="line">            &#125; </div><div class="line">            <span class="comment">/* if we can not combine base and previous memory spaces, no matter base can combine next memory space or not, </span></div><div class="line">             * we just insert base to free_list */</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                list_add_after(&amp;(prev-&gt;page_link), &amp;(base-&gt;page_link));</div><div class="line">            &#125;</div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* there are two cases here: </span></div><div class="line">     * 1. free_list is empty </div><div class="line">     * 2. we can not find a Page in free_list that address is larger than base </div><div class="line">     * In these two cases, we only need to set base page's Property flag to 1 and insert</div><div class="line">     * it to free_list */</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        list_add_before(&amp;(free_list), &amp;(base-&gt;page_link));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">        SetPageProperty(base + i);</div><div class="line">    nr_free += n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>default_free_pages(struct Page *base, size_t n)</code> 将根据传入的Page address来释放n page大小的内存空间。该函数会判断Page address是否是allocated的，也会判断是否base + n会跨界(由allocated到free的内存空间)。如果输入的Page address合法，则会将新的Page插入到free_list中的合适位置(free_list是按照Page地址由低向高排序的)。 </p>
<p>有一点需要注意，在本first-fit连续物理内存分配算法中，对于任何allocated后的Page，Property flag都为0；任何free的Page，Property flag都为1。</p>
<p>对于allocated后的Pages，第一个Page的property在这里是被清零了的，如果ucore要求只能用第一个Page来free Pages，那么allocate时，第一个Page的property就不应该清零。我们在free Page时要用property来判断Page是不是第一个Page。 </p>
<p>如果ucore规定free需要free掉整个Page块，那么我们还需要检测第一个Page的property是否和要free的page数相等。 </p>
<p>上面这几点在Lab2中并不能确定，如果之后Lab有说明，或者出现错误，我们需要重新修改这些地方。</p>
<h2 id="Task2"><a href="#Task2" class="headerlink" title="Task2"></a>Task2</h2><p>这个练习是实现寻找虚拟地址对应的页表项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* pmm.c */</span></div><div class="line"></div><div class="line"><span class="keyword">pte_t</span> *</div><div class="line">get_pte(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">bool</span> create) &#123;</div><div class="line">    <span class="keyword">pte_t</span> *pt_addr;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></div><div class="line">    <span class="keyword">uintptr_t</span> *page_la; </div><div class="line">    <span class="keyword">if</span> (pgdir[(PDX(la))] &amp; PTE_P) &#123;</div><div class="line">        pt_addr = (<span class="keyword">pte_t</span> *)(KADDR(pgdir[(PDX(la))] &amp; <span class="number">0XFFFFF000</span>)); </div><div class="line">        <span class="keyword">return</span> &amp;pt_addr[(PTX(la))]; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (create) &#123;</div><div class="line">            p = alloc_page();</div><div class="line">            <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</div><div class="line">                cprintf(<span class="string">"boot_alloc_page failed.\n"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">            &#125;</div><div class="line">            p-&gt;ref = <span class="number">1</span>;</div><div class="line">            page_la = KADDR(page2pa(p));</div><div class="line">            <span class="built_in">memset</span>(page_la, <span class="number">0x0</span>, PGSIZE); </div><div class="line">            pgdir[(PDX(la))] = ((page2pa(p)) &amp; <span class="number">0xFFFFF000</span>) | (pgdir[(PDX(la))] &amp; <span class="number">0x00000FFF</span>); </div><div class="line">            pgdir[(PDX(la))] = pgdir[(PDX(la))] | PTE_P | PTE_W | PTE_U;</div><div class="line">            <span class="keyword">return</span> &amp;page_la[PTX(la)]; </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个代码很简单, 但有几个地方还是需要注意下。<br>首先，最重要的一点就是要明白页目录和页表中存储的都是物理地址。所以当我们从页目录中获取页表的物理地址后，我们需要使用KADDR()将其转换成虚拟地址。之后就可以用这个虚拟地址直接访问对应的页表了。</p>
<p>第二， <code>*, &amp;, memset()</code> 等操作的都是虚拟地址。注意不要将物理或者线性地址用于这些操作(假设线性地址和虚拟地址不一样)。</p>
<p>第三，alloc_page()获取的是物理page对应的Page结构体，而不是我们需要的物理page。通过一系列变化(page2pa())，我们可以根据获取的Page结构体得到与之对应的物理page的物理地址，之后我们就能获得它的虚拟地址。</p>
<h2 id="Task3"><a href="#Task3" class="headerlink" title="Task3"></a>Task3</h2><p>这个练习是实现释放某虚地址所在的页并取消对应二级页表项的映射。这个练习比Task2还要简单，我就直接贴出代码了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* pmm.c */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">page_remove_pte</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">pte_t</span> *ptep)</span> &#123;</div><div class="line">    <span class="keyword">pte_t</span> *pt_addr;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></div><div class="line">    <span class="keyword">uintptr_t</span> *page_la; </div><div class="line">    <span class="keyword">if</span> ((pgdir[(PDX(la))] &amp; PTE_P) &amp;&amp; (*ptep &amp; PTE_P)) &#123;</div><div class="line">        p = pte2page(*ptep);   </div><div class="line">        page_ref_dec(p); </div><div class="line">        <span class="keyword">if</span> (p-&gt;ref == <span class="number">0</span>) </div><div class="line">            free_page(p); </div><div class="line">        *ptep = <span class="number">0</span>;</div><div class="line">        tlb_invalidate(pgdir, la);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        cprintf(<span class="string">"This pte is empty!\n"</span>); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ucore/" rel="tag"># ucore</a>
          
            <a href="/tags/OS/" rel="tag"># OS</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/05/24/ucore操作系统实验笔记-重新理解中断/" rel="next" title="ucore操作系统实验笔记 - 重新理解中断">
                <i class="fa fa-chevron-left"></i> ucore操作系统实验笔记 - 重新理解中断
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/Me and My Wife.JPG"
               alt="Ruitao Dou" />
          <p class="site-author-name" itemprop="name">Ruitao Dou</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/RdouTyping/" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://segmentfault.com/u/rdoutyping" target="_blank" title="Segmentfault">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Segmentfault
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/ruitao-dou" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/aad1970d724e" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  简书
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#系统内存的探测"><span class="nav-number">1.</span> <span class="nav-text">系统内存的探测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#INT-15h中断与E820参数"><span class="nav-number">1.1.</span> <span class="nav-text">INT 15h中断与E820参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现过程"><span class="nav-number">1.2.</span> <span class="nav-text">实现过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#物理内存空间管理的初始化"><span class="nav-number">2.</span> <span class="nav-text">物理内存空间管理的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#物理内存空间管理的初始化的过程"><span class="nav-number">2.1.</span> <span class="nav-text">物理内存空间管理的初始化的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#部分源码分析"><span class="nav-number">2.2.</span> <span class="nav-text">部分源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pages的地址"><span class="nav-number">2.2.1.</span> <span class="nav-text">pages的地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#free页的起始地址"><span class="nav-number">2.2.2.</span> <span class="nav-text">free页的起始地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化free页的信息"><span class="nav-number">2.2.3.</span> <span class="nav-text">初始化free页的信息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存段页式管理"><span class="nav-number">3.</span> <span class="nav-text">内存段页式管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#地址映射"><span class="nav-number">4.</span> <span class="nav-text">地址映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一阶段"><span class="nav-number">4.1.</span> <span class="nav-text">第一阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二阶段"><span class="nav-number">4.2.</span> <span class="nav-text">第二阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三阶段"><span class="nav-number">4.3.</span> <span class="nav-text">第三阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四阶段"><span class="nav-number">4.4.</span> <span class="nav-text">第四阶段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自映射"><span class="nav-number">5.</span> <span class="nav-text">自映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自映射的实现"><span class="nav-number">5.1.</span> <span class="nav-text">自映射的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Task1"><span class="nav-number">6.</span> <span class="nav-text">Task1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Task2"><span class="nav-number">7.</span> <span class="nav-text">Task2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Task3"><span class="nav-number">8.</span> <span class="nav-text">Task3</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ruitao Dou</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
